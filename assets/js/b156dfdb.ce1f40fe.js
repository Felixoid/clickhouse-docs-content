"use strict";(self.webpackChunkclickhouse=self.webpackChunkclickhouse||[]).push([[12437],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return c}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(a),c=r,h=d["".concat(o,".").concat(c)]||d[c]||u[c]||s;return a?n.createElement(h,i(i({ref:t},m),{},{components:a})):n.createElement(h,i({ref:t},m))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<s;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},82929:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return o},default:function(){return c},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var n=a(87462),r=a(63366),s=(a(67294),a(3905)),i=["components"],l={sidebar_label:"Other Approaches",sidebar_position:4,description:"Alternatives approaches to handling JSON"},o="Other Approaches",p={unversionedId:"en/guides/developer/working-with-json/json-other-approaches",id:"en/guides/developer/working-with-json/json-other-approaches",title:"Other Approaches",description:"Alternatives approaches to handling JSON",source:"@site/docs/en/guides/developer/working-with-json/json-other-approaches.md",sourceDirName:"en/guides/developer/working-with-json",slug:"/en/guides/developer/working-with-json/json-other-approaches",permalink:"/docs/en/guides/developer/working-with-json/json-other-approaches",editUrl:"https://github.com/ClickHouse/clickhouse-docs/blob/main/docs/en/guides/developer/working-with-json/json-other-approaches.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Other Approaches",sidebar_position:4,description:"Alternatives approaches to handling JSON"},sidebar:"english",previous:{title:"Semi-Structured Approach",permalink:"/docs/en/guides/developer/working-with-json/json-semi-structured"},next:{title:"SRE Guides",permalink:"/docs/en/guides/sre"}},m={},u=[{value:"Handle as Structured Data",id:"handle-as-structured-data",level:2},{value:"Using Nested",id:"using-nested",level:3},{value:"Using Tuples",id:"using-tuples",level:3},{value:"Using Maps",id:"using-maps",level:3},{value:"Nested vs Tuple vs Map",id:"nested-vs-tuple-vs-map",level:3},{value:"Store as String",id:"store-as-string",level:2},{value:"Visit Functions",id:"visit-functions",level:3},{value:"Using Pairwise Arrays",id:"using-pairwise-arrays",level:2},{value:"Hybrid Approach with Materialized Columns",id:"hybrid-approach-with-materialized-columns",level:2},{value:"Default vs Materialized",id:"default-vs-materialized",level:3},{value:"Assessing Storage Usage",id:"assessing-storage-usage",level:3},{value:"Using Materialized Views",id:"using-materialized-views",level:3},{value:"Updating Materialized Views",id:"updating-materialized-views",level:3},{value:"Using for Pairwise Arrays",id:"using-for-pairwise-arrays",level:3}],d={toc:u};function c(e){var t=e.components,l=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,n.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"other-approaches"},"Other Approaches"),(0,s.kt)("p",null,"Versions of ClickHouse before 22.3.1 do not support a JSON Object type. Similar functionality can be achieved, however, with some limitations."),(0,s.kt)("p",null,"These approaches can be summarized as follows:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Handle as structured data")," - explicitly map each column and ensure that the table schema is maintained if new data is added. We can exploit the tuple, map and nested data types in this case for nested structures."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Store as a string "),"- using functions to extract properties at query time or potentially adding materialized columns as needed"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Utilize the map type - "),"use the Map type to store homogenous key-value pair"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Utilize paired arrays "),"- store the data as arrays of keys and values")),(0,s.kt)("p",null,"We address each of these below, discussing their benefits and ultimate limitations that resulted in the JSON Object type development. "),(0,s.kt)("p",null,"For example, we use a simple logging dataset, a sample of which is shown below. Although the full dataset contains over 200m rows, which the user is free to download, only a sample is used in most cases to ensure queries are responsive."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@timestamp": 893964617,\n  "clientip": "40.135.0.0",\n  "request": {\n    "method": "GET",\n    "path": "/images/hm_bg.jpg",\n    "version": "HTTP/1.0"\n  },\n  "status": 200,\n  "size": 24736\n}\n')),(0,s.kt)("p",null,"The full dataset is available in s3 as numbered files of the format ",(0,s.kt)("inlineCode",{parentName:"p"},"documents-<01-25>.tar.gz"),". We utilize the first of these files ",(0,s.kt)("inlineCode",{parentName:"p"},"documents-01.tar.gz")," to ensure sample queries execute promptly:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONEachRow') LIMIT 1;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"@timestamp"),(0,s.kt)("th",{parentName:"tr",align:"left"},"clientip"),(0,s.kt)("th",{parentName:"tr",align:"left"},"request"),(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"size"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"893964617"),(0,s.kt)("td",{parentName:"tr",align:"left"},"40.135.0.0"),(0,s.kt)("td",{parentName:"tr",align:"left"},"{'method':'GET','path':'/images/hm","_","bg.jpg','version':'HTTP/1.0'}"),(0,s.kt)("td",{parentName:"tr",align:"left"},"200"),(0,s.kt)("td",{parentName:"tr",align:"left"},"24736")))),(0,s.kt)("h2",{id:"handle-as-structured-data"},"Handle as Structured Data"),(0,s.kt)("p",null,"If your JSON has a fixed schema, mapping it to an explicit schema provides the most optimal performance. Specifically, users can control codecs, configure data skipping indexes and utilize columns in primary and sort keys."),(0,s.kt)("p",null,"This approach represents the most optimal means of handling JSON. It is limited in a number of ways, however, specifically:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"JSON values need to be consistent and mappable to columns. If the data is inconsistent or dirty, insert logic will need to be modified."),(0,s.kt)("li",{parentName:"ul"},"All columns and their types must be known upfront. Changes will need to be made to the table should JSON keys be added - prior knowledge of this is required.")),(0,s.kt)("p",null,"For the example above, most of the fields have obvious types. However, we have a few options for the object request field: ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/data-types/nested-data-structures/nested/"},"nested"),", ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/data-types/tuple/"},"tuple"),", and ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions/#function-map"},"map")," (assuming no support for JSON objects)."),(0,s.kt)("h3",{id:"using-nested"},"Using Nested"),(0,s.kt)("p",null,"Below we provide an example of using nested. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE table http\n(\n   `@timestamp` Int32 EPHEMERAL 0,\n   clientip     IPv4,\n   request Nested(method LowCardinality(String), path String, version LowCardinality(String)),\n   status       UInt16,\n   size         UInt32,\n   timestamp    DateTime DEFAULT toDateTime(`@timestamp`)\n) ENGINE = MergeTree() ORDER BY (status, timestamp);\n\nSET input_format_import_nested_json = 1;\nINSERT INTO http (`@timestamp`, clientip, request.method, request.path, request.version, status, size) \nFORMAT JSONEachRow\n   {"@timestamp":897819077,"clientip":"45.212.12.0","request":{"method":["GET"],\n   "path":["/french/images/hm_nav_bar.gif"],"version":["HTTP/1.0"]},"status":200,"size":3305}\n')),(0,s.kt)("p",null,"A few important points to note here:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"We need to use the setting ",(0,s.kt)("inlineCode",{parentName:"p"},"input_format_import_nested_json "),"to insert the JSON as a nested structure. Without this, we are required to flatten the JSON i.e."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-sql"},'INSERT INTO http_uint FORMAT JSONEachRow\n{"@timestamp":897819077,"clientip":"45.212.12.0","request.method":["GET"],\n"request.path":["/french/images/hm_nav_bar.gif"],"request.version":["HTTP/1.0"],\n"status":200,"size":3305}\n'))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The nested fields method, path, and version need to be passed as JSON arrays")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The columns must be specified in INSERT - this is actually because of the EPHEMERAL column ",(0,s.kt)("inlineCode",{parentName:"p"},"@timestamp"),", which requires a type conversion."))),(0,s.kt)("p",null,"Columns can be queried using a dot notation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT clientip, status, size, `request.method` FROM http WHERE has(request.method, 'GET');\n")),(0,s.kt)("p",null,"Notice how we are required to query ",(0,s.kt)("inlineCode",{parentName:"p"},"request.method")," as an Array. It is easiest to think of a nested data structure as multiple column ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/data-types/array/"},"arrays")," of the same length. The fields method, path, and version are all separate Array(Type) columns in effect with one critical constraint: ",(0,s.kt)("strong",{parentName:"p"},"the length of the method, path, and version fields must be the same.")),(0,s.kt)("p",null,"If your nested structure fits this constraint, and you are comfortable ensuring the values are inserted as strings, nested provides a simple means of querying JSON. Note the use of Arrays for the sub-columns means the full breath ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/functions/array-functions/"},"Array functions")," can potentially be exploited, including the ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/statements/select/array-join/"},"Array Join")," clause - useful if your columns have multiple values. Additionally, nested fields can be used in primary and sort keys."),(0,s.kt)("p",null,"Given the constraints and input format for the JSON, we insert our sample dataset using the following query. Note the use of the map operators to access the request fields - this results from schema inference detecting a map for the request field in the s3 data."),(0,s.kt)("p",null,"The following statement inserts 10m rows, so this may take a few minutes to execute. Apply a LIMIT if required."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO http (`@timestamp`, clientip, request.method, request.path, request.version, status, size) \nSELECT `@timestamp`, clientip, [request['method']], [request['path']], [request['version']], status, \nsize FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONEachRow');\n")),(0,s.kt)("p",null,"Querying this data requires us to access the request fields as arrays. Below we summarize the errors and http methods over a fixed time period."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT status, request.method[1] as method, count() as c\nFROM http\nWHERE status >= 400\n  AND timestamp BETWEEN '1998-01-01 00:00:00' AND '1998-06-01 00:00:00'\nGROUP by method, status\nORDER BY c DESC LIMIT 5;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"method"),(0,s.kt)("th",{parentName:"tr",align:"left"},"c"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"11267")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"HEAD"),(0,s.kt)("td",{parentName:"tr",align:"left"},"276")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"160")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"POST"),(0,s.kt)("td",{parentName:"tr",align:"left"},"115")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"400"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"81")))),(0,s.kt)("h3",{id:"using-tuples"},"Using Tuples"),(0,s.kt)("p",null,"The nested object request can also be represented as a Tuple. This provides comparable functionality to nested, addressing some of its constraints at the expense of other limitations. For example, by not using Arrays we do not have the same constraint that subfields of an object have to be the same length. This lets us represent more varied structures. However, unlike nested fields, the subfields of tuples cannot be used in primary and sort keys."),(0,s.kt)("p",null,"First, create an example table for the http data:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE IF EXISTS http;\n\nCREATE table http\n(\n    `@timestamp` Int32 EPHEMERAL 0,\n    clientip     IPv4,\n    request Tuple(method LowCardinality(String), path String, version LowCardinality(String)),\n    status       UInt16,\n    size         UInt32,\n    timestamp    DateTime DEFAULT toDateTime(`@timestamp`)\n) ENGINE = MergeTree() ORDER BY (status, timestamp);\n")),(0,s.kt)("p",null,"Insertion of data requires changes to the nested field structure. Specifically, note how the \u201crequest\u201d object below must be passed as an array of values."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},'INSERT INTO http (`@timestamp`, clientip, request, status, size) FORMAT JSONEachRow\n    {"@timestamp":893964617,"clientip":"40.135.0.0","request":["GET", "/images/hm_bg.jpg", "HTTP/1.0"],\n    "status":200,"size":24736}\n')),(0,s.kt)("p",null,"We have minimal data in our example above, but as shown below we can query the tuple fields by their period delimited names. We also aren\u2019t required to use Array functions like nested."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT `request.method`, status, timestamp FROM http WHERE request.method = 'GET';\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"request.method"),(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"200"),(0,s.kt)("td",{parentName:"tr",align:"left"},"1998-04-30 19:30:17")))),(0,s.kt)("p",null,"The principal disadvantage of tuples, other than the requirement to convert our objects into lists, is the sub fields cannot be used as primary or sort keys. The following will thus fail."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE IF EXISTS http;\n\nCREATE table http\n(\n   `@timestamp` Int32 EPHEMERAL 0,\n   clientip     IPv4,\n   request Tuple(method LowCardinality(String), path String, version LowCardinality(String)),\n   status       UInt16,\n   size         UInt32,\n   timestamp    DateTime DEFAULT toDateTime(`@timestamp`)\n) ENGINE = MergeTree() ORDER BY (status, request.method, timestamp);\n")),(0,s.kt)("p",null,"However, the entire tuple can be used for this purpose. The following is valid."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE IF EXISTS http;\n\nCREATE table http\n(\n   `@timestamp` Int32 EPHEMERAL 0,\n   clientip     IPv4,\n   request Tuple(method LowCardinality(String), path String, version LowCardinality(String)),\n   status       UInt16,\n   size         UInt32,\n   timestamp    DateTime DEFAULT toDateTime(`@timestamp`)\n) ENGINE = MergeTree() ORDER BY (status, request, timestamp);\n")),(0,s.kt)("p",null,"As noted in ",(0,s.kt)("a",{parentName:"p",href:"./json-semi-structured"},"Semi-Structured Approach"),", the JSON object type available in 22.3 utilizes tuples for nested structures - abstracting the above complexity with a more intuitive query interface."),(0,s.kt)("p",null,"To insert our sample data from s3 we can use the following query. Note the need to form a tuple at insert time for the request field i.e. ",(0,s.kt)("inlineCode",{parentName:"p"},"(request['method'], request['path'], request['version'])"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO http(`@timestamp`, clientip, request, status, size) SELECT `@timestamp`, clientip, \n(request['method'], request['path'], request['version']), status, size FROM \ns3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONEachRow');\n")),(0,s.kt)("p",null,"To reproduce our earlier query analyzing error rates by status code, we don\u2019t require any special syntax:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"\nSELECT status, request.method as method, count() as c\nFROM http\nWHERE status >= 400\n  AND timestamp BETWEEN '1998-01-01 00:00:00' AND '1998-06-01 00:00:00'\nGROUP by method, status\nORDER BY c DESC LIMIT 5;\n")),(0,s.kt)("h3",{id:"using-maps"},"Using Maps"),(0,s.kt)("p",null,"Maps represent a simple way to represent nested structures, with some noticeable limitations: "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The fields must be of all the same type."),(0,s.kt)("li",{parentName:"ul"},"The values are also restricted to ",(0,s.kt)("a",{parentName:"li",href:"https://clickhouse.com/docs/en/sql-reference/data-types/string/"},"String"),",",(0,s.kt)("a",{parentName:"li",href:"https://clickhouse.com/docs/en/sql-reference/data-types/int-uint/"}," Integer"),",",(0,s.kt)("a",{parentName:"li",href:"https://clickhouse.com/docs/en/sql-reference/data-types/array/"}," Array"),",",(0,s.kt)("a",{parentName:"li",href:"https://clickhouse.com/docs/en/sql-reference/data-types/lowcardinality/"}," LowCardinality"),", or",(0,s.kt)("a",{parentName:"li",href:"https://clickhouse.com/docs/en/sql-reference/data-types/fixedstring/"}," FixedString")," types."),(0,s.kt)("li",{parentName:"ul"},"Accessing subfields requires a special map syntax - since the fields don\u2019t exist as columns i.e. the entire object is a column.")),(0,s.kt)("p",null,"Provided we assume the subfields of our request object are all Strings, we use a map to hold this structure. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE IF EXISTS http;\nCREATE table http\n(\n   `@timestamp` Int32 EPHEMERAL 0,\n   clientip     IPv4,\n   request Map(String, String),\n   status       UInt16,\n   size         UInt32,\n   timestamp    DateTime DEFAULT toDateTime(`@timestamp`)\n) ENGINE = MergeTree() ORDER BY (status, request, timestamp);\n")),(0,s.kt)("p",null,"Unlike Nested and Tuple, we aren\u2019t required to make changes to our JSON structures at insertion. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},'INSERT INTO http (`@timestamp`, clientip, request, status, size) FORMAT JSONEachRow\n    {"@timestamp":897819077,"clientip":"45.212.12.0","request":{"method": "GET","path":"/french/images/hm_nav_bar.gif","version":"HTTP/1.1"},"status":200,"size":3305}\n')),(0,s.kt)("p",null,"Querying these fields within the request object requires a map syntax e.g."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM http;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"clientip"),(0,s.kt)("th",{parentName:"tr",align:"left"},"request"),(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"size"),(0,s.kt)("th",{parentName:"tr",align:"left"},"timestamp"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"45.212.12.0"),(0,s.kt)("td",{parentName:"tr",align:"left"},"{'method':'GET','path':'/french/images/hm","_","nav","_","bar.gif','version':'HTTP/1.1'}"),(0,s.kt)("td",{parentName:"tr",align:"left"},"200"),(0,s.kt)("td",{parentName:"tr",align:"left"},"3305"),(0,s.kt)("td",{parentName:"tr",align:"left"},"1998-06-14 10:11:17")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT timestamp, request['method'] as method, status FROM http WHERE request['method'] = 'GET';\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"timestamp"),(0,s.kt)("th",{parentName:"tr",align:"left"},"method"),(0,s.kt)("th",{parentName:"tr",align:"left"},"status"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"1998-06-14 10:11:17"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"200")))),(0,s.kt)("p",null,"A full set of map functions is available to query this time, described ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/functions/tuple-map-functions/"},"here"),". If your data is not of a consistent type, functions exist to perform the necessary coercion. The following example, exploits the fact that data objects can also be inserted into a map in the structure",(0,s.kt)("inlineCode",{parentName:"p"}," [(key, value), (key, value),...]")," e.g. ",(0,s.kt)("inlineCode",{parentName:"p"},"[('method', 'GET'),('path', '/french/images/hm\\_nav\\_bar.gif'),('version', 'HTTP/1.1')]")),(0,s.kt)("p",null,"This function in turn allows us to insert our full s3 dataset with no need to reformat the data."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO http (`@timestamp`, clientip, request, \nstatus, size) SELECT `@timestamp`, clientip, request, status, size FROM \ns3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONEachRow');\n")),(0,s.kt)("p",null,"To reproduce our earlier query example which analyzes status codes by HTTP method, we require the use of the map syntax:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT status, request['method'] as method, count() as c\nFROM http\nWHERE status >= 400\n AND timestamp BETWEEN '1998-01-01 00:00:00' AND '1998-06-01 00:00:00'\nGROUP by method, status\nORDER BY c DESC LIMIT 5;\n")),(0,s.kt)("h3",{id:"nested-vs-tuple-vs-map"},"Nested vs Tuple vs Map"),(0,s.kt)("p",null,"Each of the above strategies for handling nested JSON has its respective advantages and disadvantages. The following captures these differences."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Requires custom INSERT format"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Requires custom notation to read fields"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Constraints on structure e.g. list lengths or types"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Object fields can be used for primary/sort keys"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Creates more columns on disk"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Nested"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Yes"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Yes*"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Yes"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Yes")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Tuple"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Yes"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},"Map"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Yes"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Yes**"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No"),(0,s.kt)("td",{parentName:"tr",align:"center"},"No")))),(0,s.kt)("p",null,"*Nested requires values (represented as arrays) to have the same length\n**Values must be the same type"),(0,s.kt)("h2",{id:"store-as-string"},"Store as String"),(0,s.kt)("p",null,"Handling data using the structured approach described in ",(0,s.kt)("a",{parentName:"p",href:"./json-other-approaches#handle-as-structured-data"},"Handle as Structured Data"),", is often not viable for those users with dynamic JSON which is either subject to change or for which the schema is not well understood. For absolute flexibility, users can simply store JSON as Strings before using functions to extract fields as required. This represents the extreme opposite to handling JSON as a structured object. This flexibility incurs costs with significant disadvantages - primarily an increase in query syntax complexity as well as degraded performance."),(0,s.kt)("p",null,"Our table schema, in this case, is trivial:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE IF EXISTS http;\nCREATE table http_json\n(\n   message String\n\n) ENGINE = MergeTree ORDER BY tuple();\n")),(0,s.kt)("p",null,"Insertion requires us to send each JSON row as a String. Here we use the format ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/interfaces/formats/#jsonasstring"},"JSONAsString")," to ensure our object is interpreted."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},'INSERT INTO http FORMAT JSONAsString\n  {"@timestamp":897819077,"clientip":"45.212.12.0","request":{"method":"GET",\n  "path":"/french/images/hm_nav_bar.gif","version":"HTTP/1.0"},"status":200,"size":3305}\n')),(0,s.kt)("p",null,"To illustrate queries we can insert our sample from s3:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO http SELECT * FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONAsString');\n")),(0,s.kt)("p",null,"The below query counts the requests with a status code greater than 200, grouping by http method."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT JSONExtractString(JSONExtractString(message, 'request'), 'method') as method,\n       JSONExtractInt(message, 'status')                                  as status,\n       count()                                                            as count\nFROM http\nWHERE status >= 400\n  AND method == 'GET'\nGROUP BY method, status;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"method"),(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"count"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"11267")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"400"),(0,s.kt)("td",{parentName:"tr",align:"left"},"81")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"160")))),(0,s.kt)("p",null,"Despite using functions to parse the String, this query should still return for the 10m rows in a few seconds. Notice how the functions require both a reference to the String field message and a path in the JSON to extract. Nested paths require functions to be nested  e.g. ",(0,s.kt)("inlineCode",{parentName:"p"},"JSONExtractString(JSONExtractString(message, 'request'), 'method')")," extracts the field ",(0,s.kt)("inlineCode",{parentName:"p"},"request.method"),". The extraction of nested paths can be simplified through the functions ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/dos/en/sql-reference/functions/json-functions/#json-query"},"JSON_QUERY")," AND ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/functions/json-functions/#json-value"},"JSON_VALUE")," as shown below:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT JSONExtractInt(message, 'status') AS status, JSON_VALUE(message, '$.request.method') as method, \ncount() as c\nFROM http\nWHERE status >= 400\n  AND toDateTime(JSONExtractUInt(message, '@timestamp')) BETWEEN '1998-01-01 00:00:00' \n  AND '1998-06-01 00:00:00'\nGROUP by method, status\nORDER BY c DESC LIMIT 5;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"method"),(0,s.kt)("th",{parentName:"tr",align:"left"},"c"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"11267")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"HEAD"),(0,s.kt)("td",{parentName:"tr",align:"left"},"276")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"160")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"POST"),(0,s.kt)("td",{parentName:"tr",align:"left"},"115")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"400"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"81")))),(0,s.kt)("p",null,"Notice the use of an xpath expression here to filter the JSON by method i.e. ",(0,s.kt)("inlineCode",{parentName:"p"},"JSON_VALUE(message, '$.request.method')"),". "),(0,s.kt)("p",null,"String functions are appreciably slower (> 10x) than explicit type conversions with indices. The above queries always require a full table scan and processing of every row. While these queries will still be fast on a small dataset such as this, performance will degrade on larger datasets."),(0,s.kt)("p",null,"The flexibility this approach provides comes at a clear performance and syntax cost. It can, however, be coupled with other approaches where users extract only the explicit fields they need for indices or frequent queries. For further details on this approach, see ",(0,s.kt)("a",{parentName:"p",href:"./json-other-approaches#hybrid-approach-with-materialized-columns"},"Hybrid approach"),"."),(0,s.kt)("h3",{id:"visit-functions"},"Visit Functions"),(0,s.kt)("p",null,"The above examples use the JSON* family of functions. These utilize a full JSON parser based on ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/simdjson/simdjson"},"simdjson"),", that is rigorous in its parsing and will distinguish between the same field nested at different levels. These functions are able to deal with JSON that is syntactically correct but not well-formatted, e.g. double spaces between keys.  "),(0,s.kt)("p",null,"A faster and more strict set of functions are available. These visitParam* functions offer potentially superior performance, primarily by making strict assumptions as to the structure and format of the JSON. Specifically:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Field names must be constants")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Consistent encoding of field names e.g. visitParamHas('{\"abc\":\"def\"}', 'abc') = 1, but visitParamHas('{\"","\\","u0061","\\","u0062","\\","u0063\":\"def\"}', 'abc') = 0")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The field names are unique across all nested structures. No differentiation is made between nesting levels, and matching is indiscriminate. In the event of multiple matching fields, the first occurrence is used.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"No special characters outside of string literals. This includes spaces. The following is invalid and will not parse."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{"@timestamp": 893964617, "clientip": "40.135.0.0", "request": {"method": "GET", \n"path": "/images/hm_bg.jpg", "version": "HTTP/1.0"}, "status": 200, "size": 24736}\n')),(0,s.kt)("p",{parentName:"li"},"  whereas, will parse correctly"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{"@timestamp":893964617,"clientip":"40.135.0.0","request":{"method":"GET",\n"path":"/images/hm_bg.jpg","version":"HTTP/1.0"},"status":200,"size":24736}\n')))),(0,s.kt)("p",null,"In some circumstances, where performance is critical and your JSON meets the above requirements,  these may be appropriate. An example of the earlier query, re-written to use visitParam functions is shown below:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT visitParamExtractUInt(message, 'status')   AS status,\n       visitParamExtractString(message, 'method') as method,\n       count()                                    as c\nFROM http\nWHERE status >= 400\n  AND toDateTime(visitParamExtractUInt(message, '@timestamp')) BETWEEN '1998-01-01 00:00:00' AND '1998-06-01 00:00:00'\nGROUP by method, status\nORDER BY c DESC LIMIT 5;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"method"),(0,s.kt)("th",{parentName:"tr",align:"left"},"c"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"11267")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"HEAD"),(0,s.kt)("td",{parentName:"tr",align:"left"},"276")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"160")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"POST"),(0,s.kt)("td",{parentName:"tr",align:"left"},"115")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"400"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"81")))),(0,s.kt)("p",null,"Note that these functions are also aliased to simpleJSON* equivalents. The above query can be rewritten to:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT simpleJSONExtractUInt(message, 'status')   AS status,\n       simpleJSONExtractString(message, 'method') as method,\n       count()                                    as c\nFROM http\nWHERE status >= 400\n  AND toDateTime(simpleJSONExtractUInt(message, '@timestamp')) BETWEEN '1998-01-01 00:00:00' \n  AND '1998-06-01 00:00:00'\nGROUP by method, status;\n")),(0,s.kt)("h2",{id:"using-pairwise-arrays"},"Using Pairwise Arrays"),(0,s.kt)("p",null,"Pairwise arrays provide a balance between the flexibility of representing JSON as Strings and the performance of a more structured approach. The schema is flexible in that any new fields can be potentially added to the root. This, however, requires a significantly more complex query syntax and isn\u2019t compatible with nested structures."),(0,s.kt)("p",null,"As an example, consider the following table:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE http_with_arrays (\n   keys Array(String),\n   values Array(String)\n)\nENGINE = MergeTree  ORDER BY tuple();\n")),(0,s.kt)("p",null,"To insert into this table, we need to structure the JSON as a list of keys and values. The following query illustrates the use of the ",(0,s.kt)("inlineCode",{parentName:"p"},"JSONExtractKeysAndValues")," to achieve this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT arrayMap(x -> x.1, JSONExtractKeysAndValues(json, 'String')) as keys,\n       arrayMap(x -> x.2, JSONExtractKeysAndValues(json, 'String')) as values\nFROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONAsString') LIMIT 1;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"keys"),(0,s.kt)("th",{parentName:"tr",align:"left"},"values"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"[","'@timestamp','clientip','request','status','size'","]"),(0,s.kt)("td",{parentName:"tr",align:"left"},"[",'\'893964617\',\'40.135.0.0\',\'{"method":"GET","path":"/images/hm',"_","bg.jpg\",\"version\":\"HTTP/1.0\"}','200','24736'","]")))),(0,s.kt)("p",null,"Note how the request column remains a nested structure represented as a string. We can insert any new keys to the root. We can also have arbitrary differences in the JSON itself. To insert into our local table, execute the following:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO http_with_arrays\nSELECT arrayMap(x ->\n                    x.1, JSONExtractKeysAndValues(message, 'String')) keys\nFROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONEachRow');\n")),(0,s.kt)("p",null,"Querying this structure requires using the indexOf function to identify the index of the required key (which should be consistent with the order of the values). This can in turn be used to access the values array column i.e. ",(0,s.kt)("inlineCode",{parentName:"p"},"values[indexOf(keys, 'status')]"),". We still require a JSON parsing method for the request column - in this case, ",(0,s.kt)("inlineCode",{parentName:"p"},"simpleJSONExtractString"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT toUInt16(values[indexOf(keys, 'status')])                           as status,\n       simpleJSONExtractString(values[indexOf(keys, 'request')], 'method') as method,\n       count()                                                             as c\nFROM http_with_arrays\nWHERE status >= 400\n  AND toDateTime(values[indexOf(keys, '@timestamp')]) BETWEEN '1998-01-01 00:00:00' AND '1998-06-01 00:00:00'\nGROUP by method, status ORDER BY c DESC LIMIT 5;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"status"),(0,s.kt)("th",{parentName:"tr",align:"left"},"method"),(0,s.kt)("th",{parentName:"tr",align:"left"},"c"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"11267")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"404"),(0,s.kt)("td",{parentName:"tr",align:"left"},"HEAD"),(0,s.kt)("td",{parentName:"tr",align:"left"},"276")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"160")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"500"),(0,s.kt)("td",{parentName:"tr",align:"left"},"POST"),(0,s.kt)("td",{parentName:"tr",align:"left"},"115")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"400"),(0,s.kt)("td",{parentName:"tr",align:"left"},"GET"),(0,s.kt)("td",{parentName:"tr",align:"left"},"81")))),(0,s.kt)("h2",{id:"hybrid-approach-with-materialized-columns"},"Hybrid Approach with Materialized Columns"),(0,s.kt)("p",null,"The approaches outlined above are not either OR. While parsing JSON fields to structured columns offers the best query performance, it also potentially incurs the highest insertion overhead if done in ClickHouse. Practically, it is also sometimes not possible due to dirty or variable data or even potentially an unknown schema. Conversely, keeping the JSON as Strings or using pairwise arrays, while flexible, significantly increases query complexity and makes accessing the data the function of someone with ClickHouse expertise."),(0,s.kt)("p",null,"As a compromise, users can use a hybrid approach: representing the JSON as a String initially, extracting columns as required. While not essential, Materialized Columns can assist with this."),(0,s.kt)("p",null,"For example, maybe we start with the following initial schema:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE IF EXISTS http;\n\nCREATE table http\n(\n    message   String,\n    method String DEFAULT JSONExtractString(JSONExtractString(message, 'request'), 'method'),\n    status    UInt16 DEFAULT toUInt16(JSONExtractInt(message, 'status')),\n    size      UInt32 DEFAULT toUInt32(JSONExtractInt(message, 'size')),\n    timestamp DateTime DEFAULT toDateTime(JSONExtractUInt(message, '@timestamp'))\n) ENGINE = MergeTree() ORDER BY (status, timestamp);\n")),(0,s.kt)("p",null,"Here we have simply moved our functions to extract data from the SELECT to DEFAULT values. This is somewhat of an artificial case as our JSON is simple and could, in reality, easily be mapped. Typically the columns extracted would be a small subset of a much larger schema."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO http (message) SELECT json as message\nFROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONAsString');\n")),(0,s.kt)("p",null,"At this point we may decide we need to add the column ",(0,s.kt)("inlineCode",{parentName:"p"},"client_ip")," after querying it frequently:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE http ADD COLUMN client_ip IPv4 DEFAULT toIPv4(JSONExtractString(message, 'clientip'));\n")),(0,s.kt)("p",null,"The above change will only be incremental, i.e., the column will not exist for data inserted prior to the change. You can still query this column as it will be computed at SELECT time - although at an additional cost. Merges will also cause this column to be added to newly formed parts. To address this, we can use a ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/statements/alter/#mutations"},"mutation")," to update the existing data:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE http UPDATE client_ip = client_ip WHERE 1 = 1\n")),(0,s.kt)("p",null,"The second call here returns immediately and executes asynchronously. Users can track the progress of the update, which requires rewriting the data on disk, using the ",(0,s.kt)("inlineCode",{parentName:"p"},"system.mutations")," table. Further details ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/statements/alter/#mutations"},"here"),". Note that this is a potentially expensive operation and should be scheduled accordingly. It is, however, more optimal than an ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/statements/optimize/"},"OPTIMIZE TABLE <table_name> FINAL")," since it only writes the changed column."),(0,s.kt)("h3",{id:"default-vs-materialized"},"Default vs Materialized"),(0,s.kt)("p",null,"The use of default columns represents one of the ways to achieve \u201cMaterialized columns\u201d. There is also a ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/statements/create/table/#materialized"},"MATERIALIZED")," column syntax. This differs from ",(0,s.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/statements/create/table/#default"},"DEFAULT")," in a few ways:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"MATERIALIZED columns cannot be provided on INSERT i.e. they must always be computed from other columns. Conversely, DEFAULT columns can be optionally provided."),(0,s.kt)("li",{parentName:"ul"},"SELECT * will skip MATERIALIZED columns i.e. they must be specifically requested. This allows a table dump to be reloaded back into a table of the same definition.")),(0,s.kt)("h3",{id:"assessing-storage-usage"},"Assessing Storage Usage"),(0,s.kt)("p",null,"While extracting columns incurs a storage cost, typically, this can be minimized with a careful selection of codecs. Users will often wish to assess the cost of materializing a column prior. This cost only has a storage overhead if not queried - during the column-oriented nature of ClickHouse. We recommend testing the materialization on a subset of the data using a test table. The cost can, in turn, be computed using the following query, which can also provide an estimate of the compression achieved."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT table,\n      name,\n      type,\n      compression_codec,\n      formatReadableSize(data_compressed_bytes)       as compressed_size,\n      formatReadableSize(data_uncompressed_bytes)     as uncompressed_size,\n      data_compressed_bytes / data_uncompressed_bytes as compression_ratio\nFROM system.columns\nWHERE database = currentDatabase()\nORDER BY table, name;\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"table"),(0,s.kt)("th",{parentName:"tr",align:"left"},"name"),(0,s.kt)("th",{parentName:"tr",align:"left"},"type"),(0,s.kt)("th",{parentName:"tr",align:"left"},"compression","_","codec"),(0,s.kt)("th",{parentName:"tr",align:"left"},"compressed","_","size"),(0,s.kt)("th",{parentName:"tr",align:"left"},"uncompressed","_","size"),(0,s.kt)("th",{parentName:"tr",align:"left"},"compression","_","ratio"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"http"),(0,s.kt)("td",{parentName:"tr",align:"left"},"client","_","ip"),(0,s.kt)("td",{parentName:"tr",align:"left"},"IPv4"),(0,s.kt)("td",{parentName:"tr",align:"left"}),(0,s.kt)("td",{parentName:"tr",align:"left"},"23.51 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"38.15 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"0.61624925")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"http"),(0,s.kt)("td",{parentName:"tr",align:"left"},"message"),(0,s.kt)("td",{parentName:"tr",align:"left"},"String"),(0,s.kt)("td",{parentName:"tr",align:"left"}),(0,s.kt)("td",{parentName:"tr",align:"left"},"203.00 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"1.48 GiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"0.1336674472634663")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"http"),(0,s.kt)("td",{parentName:"tr",align:"left"},"method"),(0,s.kt)("td",{parentName:"tr",align:"left"},"String"),(0,s.kt)("td",{parentName:"tr",align:"left"}),(0,s.kt)("td",{parentName:"tr",align:"left"},"363.75 KiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"38.18 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"0.009304780749750751")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"http"),(0,s.kt)("td",{parentName:"tr",align:"left"},"size"),(0,s.kt)("td",{parentName:"tr",align:"left"},"UInt32"),(0,s.kt)("td",{parentName:"tr",align:"left"}),(0,s.kt)("td",{parentName:"tr",align:"left"},"24.19 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"38.15 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"0.6341134")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"http"),(0,s.kt)("td",{parentName:"tr",align:"left"},"status"),(0,s.kt)("td",{parentName:"tr",align:"left"},"UInt16"),(0,s.kt)("td",{parentName:"tr",align:"left"}),(0,s.kt)("td",{parentName:"tr",align:"left"},"87.49 KiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"19.07 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"0.00447955")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"http"),(0,s.kt)("td",{parentName:"tr",align:"left"},"timestamp"),(0,s.kt)("td",{parentName:"tr",align:"left"},"DateTime"),(0,s.kt)("td",{parentName:"tr",align:"left"}),(0,s.kt)("td",{parentName:"tr",align:"left"},"4.98 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"38.15 MiB"),(0,s.kt)("td",{parentName:"tr",align:"left"},"0.1306381")))),(0,s.kt)("h3",{id:"using-materialized-views"},"Using Materialized Views"),(0,s.kt)("p",null,"Using the hybrid approach described above requires significant processing at insertion time. This complicates data insertion logic and potentially introduces fragility in your data ingestion layer. To address this, we can exploit materialized views."),(0,s.kt)("p",null,"The general concept here is to exploit a table with the null engine for receiving inserts. This table engine doesn\u2019t store any data and acts as a \u201cbuffer\u201d for the materialized view only. For each insert block, the materialized view will trigger, perform the processing the required and insert rows into a target table that we can in turn query. In cases where we need to update the schema, extracting a new field from the blob, we simply update our table schema and then modify the materialized view accordingly to extract the field. Our materialized view and null table engine effectively act as an ETL pipeline, as shown below:"),(0,s.kt)("img",{src:a(23820).Z,class:"image",alt:"Working with JSON",style:{width:"100%"}}),(0,s.kt)("p",null,"First we create our null table engine for receiving inserts:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE http_etl (\n   message String\n) ENGINE = Null;\n")),(0,s.kt)("p",null,"Our target MergeTree table has a subset of the fields - ones we are maybe confident will occur in the JSON string. Note we retain a String field message for other data that can be used with JSON* functions if required."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"DROP TABLE IF EXISTS http;\n\nCREATE table http\n(\n    message   String,\n    method String,\n    status    UInt16,\n    size      UInt32,\n    timestamp DateTime\n) ENGINE = MergeTree() ORDER BY (status, timestamp);\n")),(0,s.kt)("p",null,"Our materialized view in turn extracts the fields that have been declared in the http table schema."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE MATERIALIZED VIEW http_mv TO http AS\nSELECT message,\n       JSONExtractString(JSONExtractString(message, 'request'), 'method') as method,\n       toUInt16(JSONExtractInt(message, 'status'))                  as status,\n       toUInt32(JSONExtractInt(message, 'size'))                       as size,\n       toDateTime(JSONExtractUInt(message, '@timestamp')) as timestamp\nFROM http_etl;\n")),(0,s.kt)("p",null,"Using the sample data from our s3 bucket, the insert is simplified to:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO http_etl SELECT json as message FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONAsString');\n")),(0,s.kt)("p",null,"Our analysis of error codes and http methods thus becomes trivial:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT status,\n      method,\n      count() as c\nFROM http\nWHERE status >= 400\n AND timestamp BETWEEN '1998-01-01 00:00:00' AND '1998-06-01 00:00:00'\nGROUP by method, status ORDER BY c DESC;\n")),(0,s.kt)("h3",{id:"updating-materialized-views"},"Updating Materialized Views"),(0,s.kt)("p",null,"Suppose we later wish to extract the field ",(0,s.kt)("inlineCode",{parentName:"p"},"client_ip")," from our JSON blob. First we update our target table."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE http\n    ADD COLUMN client_ip IPv4;\n")),(0,s.kt)("p",null,"Using the setting ",(0,s.kt)("inlineCode",{parentName:"p"},"allow_experimental_alter_materialized_view_structure")," we can modify our Materialized View:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"SET allow_experimental_alter_materialized_view_structure = 1;\nALTER TABLE http_mv\n   MODIFY QUERY SELECT message,\n   JSONExtractString(JSONExtractString(message, 'request'), 'method') as method,\n   toUInt16(JSONExtractInt(message, 'status')) as status,\n   toUInt32(JSONExtractInt(message, 'size')) as size,\n   toIPv4(JSONExtractString(message, 'clientip')) as client_ip,\n   toDateTime(JSONExtractUInt(message, '@timestamp')) as timestamp\n   FROM http_etl;\n")),(0,s.kt)("p",null,"Note how this feature is experimental. You can alternatively drop the view using ",(0,s.kt)("inlineCode",{parentName:"p"},"DROP VIEW")," and recreate it - however this does require pausing insertions."),(0,s.kt)("p",null,"If an update of the target table is required, see the use of mutations in ",(0,s.kt)("a",{parentName:"p",href:"#hybrid-approach-with-materialized-columns"},"Hybrid Approach"),"."),(0,s.kt)("h3",{id:"using-for-pairwise-arrays"},"Using for Pairwise Arrays"),(0,s.kt)("p",null,"In the above example, we represented fields we wished to frequently query explicitly as columns. A materialized view could also be potentially used to extract pairwise arrays. This shifts potentially expensive logic from the SELECT statement. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE http_with_arrays\n(\n   keys Array(String),\n   values Array(String)\n)\n   ENGINE = MergeTree ORDER BY tuple();\n\nCREATE MATERIALIZED VIEW http_mv TO http_with_arrays AS\nSELECT arrayMap(x -> x.1, JSONExtractKeysAndValues(message, 'String')) as keys,\n      arrayMap(x -> x.2, JSONExtractKeysAndValues(message, 'String')) as values \nFROM http_etl;\n\nINSERT INTO http_etl\nSELECT json as message\nFROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/http/documents-01.ndjson.gz', \n'JSONAsString');\n")))}c.isMDXComponent=!0},23820:function(e,t,a){t.Z=a.p+"assets/images/working-with-json_01-6328ea72616206abb644303060a14d6f.png"}}]);